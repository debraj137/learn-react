What is state?
---------------------------------------
State = data that changes over time
Examples:counter value, form input, login status

Why Components Re-render (INTERVIEW ANSWER)
-------------------------------------------------
Correct answer:
A component re-renders when:
Its state updates,Its props change (by reference),Its parent re-renders,Context value changes
ğŸ“Œ NOT because React is slow
ğŸ“Œ NOT because Virtual DOM is bad

API Best Practices (INTERVIEW ANSWER)
--------------------------------------------------------
âœ” Fetch inside useEffect
âœ” Handle loading & error
âœ” Cleanup side effects
âœ” Donâ€™t fetch during render
âœ” Avoid unnecessary calls
âœ” Separate logic when it grows (custom hooks later)

ğŸ“Œ Interview-ready sentence:
-----------------------------------------------------------------
â€œI use useEffect for side effects like data fetching, manage loading and error states, and clean up effects to avoid memory leaks or race conditions.â€

LESSON 7: Form Performance Optimization (INTERVIEW TOPIC)
--------------------------------------------------------------------
Problem:Controlled inputs re-render on every keystroke.

Solutions: âœ” Use useRef when needed, âœ” Use React Hook Form, âœ” Avoid unnecessary state
âœ” Split big forms into components

ğŸ“Œ Interview line:
--------------------------------------------------
â€œFor large forms, I prefer React Hook Form because it minimizes re-renders and improves performance.â€

ğŸ§© LESSON 8: Rules of Hooks (MUST MEMORIZE)
-------------------------------------------------------------------
âŒ Donâ€™t call hooks:inside loops,inside conditions,inside nested functions

âœ… Call hooks:at top level,inside React components,inside custom hooks

ğŸ“Œ Rule:Hooks must run in the same order every render.

ğŸ§© LESSON 9: When NOT to Use Hooks (SENIOR ANSWER)
--------------------------------------------------------------
âŒ Donâ€™t use hooks:
just to look smart
for simple values
for premature optimization

âœ” Use hooks:
when state exists
when side effects exist
when logic is reusable

ğŸ§© LESSON 3: Global State Patterns (MENTAL MODEL)
Types of state
State type	Example	Tool
Local	input, toggle	useState
Shared	filters, tabs	lifting
Global	auth, theme	Context
Server	API data	React Query

ğŸ§© LESSON 6: When to Choose Which (INTERVIEW GOLD)
Decision table
Situation	                            Use
Simple component	                    useState
Shared sibling state	                Lift state
Theme / Auth	                        Context
Large complex app	                    Redux Toolkit
Small global state	                    Zustand
Server data	                            React Query

ğŸ“Œ Interview line:

â€œI choose state tools based on scope and complexity, not preference.â€

ğŸ§© LESSON 7: State Normalization Principles
âŒ Bad (nested state)
users: [
  { id: 1, posts: [{ id: 10 }, { id: 11 }] }
]

âœ… Good (normalized)
users: {
  1: { id: 1, posts: [10, 11] }
},
posts: {
  10: { id: 10 },
  11: { id: 11 }
}


ğŸ§  Benefits:
Easier updates
No duplication
Better performance
Used heavily in Redux.

//////////////////////////////////////////////////////
Client State
----------------------------------
State that lives only in the browser
Examples: form input, modal open/close, theme, selected tab
ğŸ‘‰ Managed with: useState, useReducer, Context, Redux, Zustand

Server State
--------------------------------------------------
State that comes from an external server
Examples: users list, products, bookings, orders, profile data

âš ï¸ Server state has problems:
--------------------------------------------
loading, error, caching, refetching, stale data

ğŸ‘‰ React Query exists to solve these problems
âŒ Old way (not ideal)
useEffect(() => {
  fetch("/api/users")
    .then(res => res.json())
    .then(setUsers);
}, []);

âœ… Modern way
useQuery({ queryKey: ["users"], queryFn: fetchUsers });

ğŸ§  Key idea:
---------------------------------------
Server state â‰  client state

//////////////////////////////////////////////////////////////////////
ğŸ§© LESSON 1: What is React Query (TanStack Query)?
---------------------------------------------------------
React Query is a server-state manager.
It: fetches data, caches it, refetches automatically, handles loading & error, avoids duplicate requests

ğŸ§  Mental model:
--------------------------------------------------------------------------
â€œReact Query is useEffect + cache + retry + refetch done rightâ€

/////////////////////////////////////////////////////////////////////////////////////////
ğŸ§© LESSON 4: Query Keys & Caching (CRITICAL)
--------------------------------------------------------
Query Key = cache identity
queryKey: ["users"]
If React Query sees the same key again:
it uses cached data
avoids refetching

ğŸ§ª Practice 2: Param-based cache
useQuery({
  queryKey: ["user", userId],
  queryFn: () => fetchUser(userId)
});


ğŸ§  Different userId â†’ different cache entry.
ğŸ“Œ Interview line:
--------------------------------------------------------------------
â€œReact Query caches data based on query keys.â€

/////////////////////////////////////////////////////////////////////////////////////
ğŸ§© LESSON 5: Background Refetching (MAGIC FEATURE)
-------------------------------------------------------------------
React Query keeps data fresh automatically.

By default:
refetches on window focus
refetches when network reconnects

ğŸ§ª Practice 3: Observe refetch
Load page
Switch tab
Come back
Network request runs again

ğŸ§  This is free â€” no code needed.

You can control it:
---------------------------------------------------------
useQuery({
  queryKey: ["users"],
  queryFn: fetchUsers,
  refetchOnWindowFocus: false
});

////////////////////////////////////////////////////////////////////////////
ğŸ§© LESSON 7: Optimistic Updates (ADVANCED, INTERVIEW GOLD)
--------------------------------------------------------------
Problem: Waiting for server response feels slow âŒ

Solution: Update UI before server responds.

ğŸ§ª Practice 5: Optimistic update pattern
-------------------------------------------------------------
const mutation = useMutation({
  mutationFn: addUser,
  onMutate: async (newUser) => {
    await queryClient.cancelQueries(["users"]);

    const previousUsers =
      queryClient.getQueryData(["users"]);

    queryClient.setQueryData(["users"], old => [
      ...old,
      { id: Date.now(), ...newUser }
    ]);

    return { previousUsers };
  },
  onError: (_err, _newUser, context) => {
    queryClient.setQueryData(
      ["users"],
      context.previousUsers
    );
  },
  onSettled: () => {
    queryClient.invalidateQueries(["users"]);
  }
});


ğŸ§  Flow:
Update UI immediately
Roll back if error
Sync with server later

ğŸ“Œ Interview line:
---------------------------------------------------------------------------------
â€œOptimistic updates improve UX by updating UI before the server confirms.â€

////////////////////////////////////////////////////////////////////////////////////////
ğŸ§© LESSON 8: Error & Loading Handling (PRODUCTION)
---------------------------------------------------------------
React Query gives: isLoading, isError, error

if (isLoading) return <Spinner />;
if (isError) return <ErrorBox />;

ğŸ§  No more manual flags.

/////////////////////////////////////////////////////////////////////////////////////////
ğŸ§© LESSON 9: Caching Strategies (INTERVIEW TOPIC)
-------------------------------------------------------------
Key options:
useQuery({
  staleTime: 5000,  // data is fresh for 5s
  cacheTime: 300000 // cache stays for 5 min
});


staleTime â†’ when refetch starts
cacheTime â†’ when cache is garbage-collected

ğŸ§  Used heavily in real apps.

ğŸ¯ INTERVIEW-READY SUMMARY (SAVE THIS)
-------------------------------------------------------------
â€œI treat server state separately from client state. I use React Query to fetch, cache, refetch, and mutate server data. It handles loading and error states automatically, supports background refetching, and enables optimistic updates for better UX.â€

//////////////////////////////////////////////////////////////////////////////////////
ğŸ§© LESSON 2: Memoization Strategies (BIG IDEA)
Memoization = â€œremember previous resultâ€
React memoization tools:
------------------------------------------
React.memo â†’ memoize components
useMemo â†’ memoize values
useCallback â†’ memoize functions

////////////////////////////////////////////////////////////////////////////////////////////
ğŸ§© LESSON 6: Avoiding Over-Optimization (VERY IMPORTANT)
------------------------------------------------------------------
âŒ Common mistakes
Wrapping everything in useMemo
Using useCallback everywhere
Optimizing before measuring

ğŸ§  Rule:
------------------------------------------------------------
Optimize only when you see a problem

ğŸ“Œ Interview line:
------------------------------------------------------------------------------
â€œI optimize based on profiling, not assumptions.â€

/////////////////////////////////////////////////////////////////////////////////////////
ğŸ§© LESSON 2: Try/Catch Patterns in UI
-----------------------------------------------------
What try/catch CAN do
---------------------------------
âœ” Catch async errors
âœ” Catch API failures

What try/catch CANNOT do
--------------------------------------
âŒ Catch render errors
âŒ Catch JSX errors

///////////////////////////////////////////////////////////////////////////////////////////////
ğŸ§© LESSON 4: Empty States (VERY IMPORTANT)
-------------------------------------------------------
What is an empty state?
When data exists, but itâ€™s empty
Examples: no bookings, empty cart, no search results

âŒ Blank screen is BAD
âœ… Clear message is GOOD

/////////////////////////////////////////////////////////////////////////////////////////////////
ğŸ§© LESSON 5: Fallback UI Patterns
Fallback UI = temporary UI while something happens
Used for: loading, errors, lazy loading, permissions

ğŸ§ª Practice 5: Loading fallback
-------------------------------------------------------------
ğŸ“„ File: src/App.jsx
function App() {
  const isLoading = true;

  if (isLoading) {
    return <p>Loading...</p>;
  }

  return <p>Data ready</p>;
}

export default App;

ğŸ§ª Practice 6: Suspense fallback
------------------------------------------------------------
<Suspense fallback={<p>Loading page...</p>}>
  <Dashboard />
</Suspense>


ğŸ§  Fallbacks improve perceived performance.

//////////////////////////////////////////////////////////////////////////
ğŸ§© LESSON 6: Putting It All Together (REAL PATTERN)
-----------------------------------------------------------------
Real-world flow
Show loading fallback
Handle error
Handle empty state
Render data
Catch unexpected crashes

ğŸ¯ INTERVIEW-READY SUMMARY (SAVE THIS)
-----------------------------------------------------------------
â€œI handle errors at multiple levels: try/catch for async logic, Error Boundaries for UI crashes, global error components for consistency, and explicit empty and fallback states to ensure good UX.â€

//////////////////////////////////////////////////////////////////////////////////////////////////
ğŸ§© LESSON 6: Accessibility Testing Mindset (INTERVIEW GOLD)

You donâ€™t need to be an expert tester â€” just follow this mindset.

âœ… Manual checks you SHOULD do

Can I navigate with Tab only?

Is focus visible?

Are buttons actually <button>?

Are forms properly labeled?

Do error messages make sense?

ğŸ§ª Keyboard test (try this now)

Open your app

Put mouse away

Use only Tab, Enter, Shift+Tab

If you get stuck â†’ accessibility issue.

ğŸ§ª Tools (just awareness)

Chrome DevTools â†’ Lighthouse

Screen readers (NVDA, VoiceOver)

ESLint a11y rules (later)

ğŸ“Œ Interview line:

â€œI test accessibility by keyboard navigation and semantic HTML before relying on tools.â€

ğŸ¯ INTERVIEW-READY SUMMARY (SAVE THIS)

â€œI build accessible React apps using semantic HTML, proper labels, keyboard-friendly components, focus management with useRef, ARIA only when necessary, and I test accessibility using keyboard navigation.â€

/////////////////////////////////////////////////////////////////////////////////////////////
ğŸ§  LESSON 1: Testing Philosophy (VERY IMPORTANT)
------------------------------------------------------------
Before writing code, understand this:
âŒ Bad testing mindset
------------------------------------
Testing implementation details
Testing internal state
Testing every small function blindly

âœ… Good testing mindset
--------------------------------------------
â€œTest what the user sees and does.â€
React Testing Library principle: The more your tests resemble how users use your software, the more confidence they give you.
/////////////////////////////////////////////////////////////////////////////////////////////////////
ğŸ§© LESSON 7: What to Test vs What NOT to Test
âœ… What to test
----------------------------------
User interactions, Conditional rendering, Form validation, API success/error states, Edge cases

âŒ What NOT to test
---------------------------------------------
Implementation details, React internals, CSS styling specifics, Library behavior (React Router internals)

ğŸ¯ INTERVIEW-READY SUMMARY
----------------------------------------
â€œI follow user-centric testing principles. I use React Testing Library to test UI behavior, mock API calls to isolate components, and focus on testing user interactions rather than implementation details.â€

/////////////////////////////////////////////////////////////////////////////////////////////////
ğŸ§  Debugging Workflow (REAL WORLD)
------------------------------------------------------------
When something breaks: Check console errors, Inspect component in DevTools, Check props/state, Add console logs, Use Profiler if performance issue, Verify dependency arrays

ğŸ¯ INTERVIEW-READY SUMMARY
-------------------------------------------------
â€œI use React DevTools to inspect component trees, the Profiler to measure re-renders, console debugging to track state changes, and I watch for common issues like infinite effects, stale closures, and unnecessary renders.â€

////////////////////////////////////////////////////////////////////////////////////////////////