What is state?
---------------------------------------
State = data that changes over time
Examples:counter value, form input, login status

Why Components Re-render (INTERVIEW ANSWER)
-------------------------------------------------
Correct answer:
A component re-renders when:
Its state updates,Its props change (by reference),Its parent re-renders,Context value changes
ğŸ“Œ NOT because React is slow
ğŸ“Œ NOT because Virtual DOM is bad

API Best Practices (INTERVIEW ANSWER)
--------------------------------------------------------
âœ” Fetch inside useEffect
âœ” Handle loading & error
âœ” Cleanup side effects
âœ” Donâ€™t fetch during render
âœ” Avoid unnecessary calls
âœ” Separate logic when it grows (custom hooks later)

ğŸ“Œ Interview-ready sentence:
-----------------------------------------------------------------
â€œI use useEffect for side effects like data fetching, manage loading and error states, and clean up effects to avoid memory leaks or race conditions.â€

LESSON 7: Form Performance Optimization (INTERVIEW TOPIC)
--------------------------------------------------------------------
Problem:Controlled inputs re-render on every keystroke.

Solutions: âœ” Use useRef when needed, âœ” Use React Hook Form, âœ” Avoid unnecessary state
âœ” Split big forms into components

ğŸ“Œ Interview line:
--------------------------------------------------
â€œFor large forms, I prefer React Hook Form because it minimizes re-renders and improves performance.â€

ğŸ§© LESSON 8: Rules of Hooks (MUST MEMORIZE)
-------------------------------------------------------------------
âŒ Donâ€™t call hooks:inside loops,inside conditions,inside nested functions

âœ… Call hooks:at top level,inside React components,inside custom hooks

ğŸ“Œ Rule:Hooks must run in the same order every render.

ğŸ§© LESSON 9: When NOT to Use Hooks (SENIOR ANSWER)
--------------------------------------------------------------
âŒ Donâ€™t use hooks:
just to look smart
for simple values
for premature optimization

âœ” Use hooks:
when state exists
when side effects exist
when logic is reusable

ğŸ§© LESSON 3: Global State Patterns (MENTAL MODEL)
Types of state
State type	Example	Tool
Local	input, toggle	useState
Shared	filters, tabs	lifting
Global	auth, theme	Context
Server	API data	React Query

ğŸ§© LESSON 6: When to Choose Which (INTERVIEW GOLD)
Decision table
Situation	                            Use
Simple component	                    useState
Shared sibling state	                Lift state
Theme / Auth	                        Context
Large complex app	                    Redux Toolkit
Small global state	                    Zustand
Server data	                            React Query

ğŸ“Œ Interview line:

â€œI choose state tools based on scope and complexity, not preference.â€

ğŸ§© LESSON 7: State Normalization Principles
âŒ Bad (nested state)
users: [
  { id: 1, posts: [{ id: 10 }, { id: 11 }] }
]

âœ… Good (normalized)
users: {
  1: { id: 1, posts: [10, 11] }
},
posts: {
  10: { id: 10 },
  11: { id: 11 }
}


ğŸ§  Benefits:
Easier updates
No duplication
Better performance
Used heavily in Redux.

//////////////////////////////////////////////////////
Client State
----------------------------------
State that lives only in the browser
Examples: form input, modal open/close, theme, selected tab
ğŸ‘‰ Managed with: useState, useReducer, Context, Redux, Zustand

Server State
--------------------------------------------------
State that comes from an external server
Examples: users list, products, bookings, orders, profile data

âš ï¸ Server state has problems:
--------------------------------------------
loading, error, caching, refetching, stale data

ğŸ‘‰ React Query exists to solve these problems
âŒ Old way (not ideal)
useEffect(() => {
  fetch("/api/users")
    .then(res => res.json())
    .then(setUsers);
}, []);

âœ… Modern way
useQuery({ queryKey: ["users"], queryFn: fetchUsers });

ğŸ§  Key idea:
---------------------------------------
Server state â‰  client state

//////////////////////////////////////////////////////////////////////
ğŸ§© LESSON 1: What is React Query (TanStack Query)?
---------------------------------------------------------
React Query is a server-state manager.
It: fetches data, caches it, refetches automatically, handles loading & error, avoids duplicate requests

ğŸ§  Mental model:
--------------------------------------------------------------------------
â€œReact Query is useEffect + cache + retry + refetch done rightâ€

/////////////////////////////////////////////////////////////////////////////////////////
ğŸ§© LESSON 4: Query Keys & Caching (CRITICAL)
--------------------------------------------------------
Query Key = cache identity
queryKey: ["users"]
If React Query sees the same key again:
it uses cached data
avoids refetching

ğŸ§ª Practice 2: Param-based cache
useQuery({
  queryKey: ["user", userId],
  queryFn: () => fetchUser(userId)
});


ğŸ§  Different userId â†’ different cache entry.
ğŸ“Œ Interview line:
--------------------------------------------------------------------
â€œReact Query caches data based on query keys.â€

/////////////////////////////////////////////////////////////////////////////////////
ğŸ§© LESSON 5: Background Refetching (MAGIC FEATURE)
-------------------------------------------------------------------
React Query keeps data fresh automatically.

By default:
refetches on window focus
refetches when network reconnects

ğŸ§ª Practice 3: Observe refetch
Load page
Switch tab
Come back
Network request runs again

ğŸ§  This is free â€” no code needed.

You can control it:
---------------------------------------------------------
useQuery({
  queryKey: ["users"],
  queryFn: fetchUsers,
  refetchOnWindowFocus: false
});

////////////////////////////////////////////////////////////////////////////
ğŸ§© LESSON 7: Optimistic Updates (ADVANCED, INTERVIEW GOLD)
--------------------------------------------------------------
Problem: Waiting for server response feels slow âŒ

Solution: Update UI before server responds.

ğŸ§ª Practice 5: Optimistic update pattern
-------------------------------------------------------------
const mutation = useMutation({
  mutationFn: addUser,
  onMutate: async (newUser) => {
    await queryClient.cancelQueries(["users"]);

    const previousUsers =
      queryClient.getQueryData(["users"]);

    queryClient.setQueryData(["users"], old => [
      ...old,
      { id: Date.now(), ...newUser }
    ]);

    return { previousUsers };
  },
  onError: (_err, _newUser, context) => {
    queryClient.setQueryData(
      ["users"],
      context.previousUsers
    );
  },
  onSettled: () => {
    queryClient.invalidateQueries(["users"]);
  }
});


ğŸ§  Flow:
Update UI immediately
Roll back if error
Sync with server later

ğŸ“Œ Interview line:
---------------------------------------------------------------------------------
â€œOptimistic updates improve UX by updating UI before the server confirms.â€

////////////////////////////////////////////////////////////////////////////////////////
ğŸ§© LESSON 8: Error & Loading Handling (PRODUCTION)
---------------------------------------------------------------
React Query gives: isLoading, isError, error

if (isLoading) return <Spinner />;
if (isError) return <ErrorBox />;

ğŸ§  No more manual flags.

/////////////////////////////////////////////////////////////////////////////////////////
ğŸ§© LESSON 9: Caching Strategies (INTERVIEW TOPIC)
-------------------------------------------------------------
Key options:
useQuery({
  staleTime: 5000,  // data is fresh for 5s
  cacheTime: 300000 // cache stays for 5 min
});


staleTime â†’ when refetch starts
cacheTime â†’ when cache is garbage-collected

ğŸ§  Used heavily in real apps.

ğŸ¯ INTERVIEW-READY SUMMARY (SAVE THIS)
-------------------------------------------------------------
â€œI treat server state separately from client state. I use React Query to fetch, cache, refetch, and mutate server data. It handles loading and error states automatically, supports background refetching, and enables optimistic updates for better UX.â€

//////////////////////////////////////////////////////////////////////////////////////
ğŸ§© LESSON 2: Memoization Strategies (BIG IDEA)
Memoization = â€œremember previous resultâ€
React memoization tools:
------------------------------------------
React.memo â†’ memoize components
useMemo â†’ memoize values
useCallback â†’ memoize functions

////////////////////////////////////////////////////////////////////////////////////////////
ğŸ§© LESSON 6: Avoiding Over-Optimization (VERY IMPORTANT)
------------------------------------------------------------------
âŒ Common mistakes
Wrapping everything in useMemo
Using useCallback everywhere
Optimizing before measuring

ğŸ§  Rule:
------------------------------------------------------------
Optimize only when you see a problem

ğŸ“Œ Interview line:
------------------------------------------------------------------------------
â€œI optimize based on profiling, not assumptions.â€

/////////////////////////////////////////////////////////////////////////////////////////
ğŸ§© LESSON 2: Try/Catch Patterns in UI
-----------------------------------------------------
What try/catch CAN do
---------------------------------
âœ” Catch async errors
âœ” Catch API failures

What try/catch CANNOT do
--------------------------------------
âŒ Catch render errors
âŒ Catch JSX errors

///////////////////////////////////////////////////////////////////////////////////////////////